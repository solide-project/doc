"use strict";(self.webpackChunksolide_docs=self.webpackChunksolide_docs||[]).push([[8390],{890:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>l,default:()=>f,frontMatter:()=>d,metadata:()=>h,toc:()=>u});var a=n(4848),s=n(8453),i=(n(6540),n(2168)),r=n(3456),o=n(9900),c=n(2345);const d={slug:"/ethereum/erc4337/entrypoint",title:"ERC4337 - Decoding Ethereum's EntryPoint",image:"https://raw.githubusercontent.com/solide-project/docs/master/static/img/blog/ethereum-entry-point.png",authors:["p"],tags:["erc4337","account-abstraction","ethereum","entry-point"]},l=void 0,h={permalink:"/doc/blog/ethereum/erc4337/entrypoint",source:"@site/blog/erc4337/entry-point/2024-03-02-index.md",title:"ERC4337 - Decoding Ethereum's EntryPoint",description:"<BlogCoverImage",date:"2024-03-02T00:00:00.000Z",formattedDate:"March 2, 2024",tags:[{label:"erc4337",permalink:"/doc/blog/tags/erc-4337"},{label:"account-abstraction",permalink:"/doc/blog/tags/account-abstraction"},{label:"ethereum",permalink:"/doc/blog/tags/ethereum"},{label:"entry-point",permalink:"/doc/blog/tags/entry-point"}],readingTime:.1,hasTruncateMarker:!1,authors:[{name:"P",title:"Software Engineer @ Solide",url:"https://github.com/solide-project",imageURL:"https://avatars.githubusercontent.com/u/154510112?s=200&v=4",key:"p"}],frontMatter:{slug:"/ethereum/erc4337/entrypoint",title:"ERC4337 - Decoding Ethereum's EntryPoint",image:"https://raw.githubusercontent.com/solide-project/docs/master/static/img/blog/ethereum-entry-point.png",authors:["p"],tags:["erc4337","account-abstraction","ethereum","entry-point"]},unlisted:!1,prevItem:{title:"ERC4337 - Paymaster",permalink:"/doc/blog/ethereum/erc4337/paymaster"},nextItem:{title:"Welcome",permalink:"/doc/blog/welcome"}},p={authorsImageUrls:[void 0]},u=[];function m(e){return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(r.A,{src:"https://raw.githubusercontent.com/solide-project/docs/master/static/img/blog/ethereum-entry-point.png"}),"\n",(0,a.jsx)(i.A,{url:"https://solidewidget.azurewebsites.net/address/1/0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789"}),"\n",(0,a.jsx)(o.Ay,{}),"\n",(0,a.jsx)(c.Ay,{})]})}function f(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(m,{...e})}):m()}},9900:(e,t,n)=>{n.d(t,{Ay:()=>r});var a=n(4848),s=n(8453);function i(e){const t={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.h2,{id:"basic",children:"Basic"}),"\n",(0,a.jsxs)(t.p,{children:["Before we go into the details of the EntryPoint, we need to understand the basic flow of how the EntryPoint works. The EntryPoint is a smart contract that is used to execute ",(0,a.jsx)(t.code,{children:"UserOperations"}),". The ",(0,a.jsx)(t.code,{children:"UserOperation"})," is a struct that contains all the necessary information to execute a transaction. The EntryPoint is used to execute multiple UserOperations at once. This is done to save gas costs and to make the execution of transactions more efficient."]}),"\n",(0,a.jsx)(t.h3,{id:"useroperation",children:"UserOperation"}),"\n",(0,a.jsxs)(t.p,{children:["The primary data structure for user interaction within the Account Abstraction framework is encapsulated in ",(0,a.jsx)(t.code,{children:"interfaces/UserOperation.sol"}),". This structure is typically created by the Bundler and transmitted to the EntryPoint contract. The ",(0,a.jsx)(t.code,{children:"UserOperation"})," struct comprises the following fields:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-solidity",children:"struct UserOperation {\r\n    address sender;\r\n    uint256 nonce;\r\n    bytes initCode;\r\n    bytes callData;\r\n    uint256 callGasLimit;\r\n    uint256 verificationGasLimit;\r\n    uint256 preVerificationGas;\r\n    uint256 maxFeePerGas;\r\n    uint256 maxPriorityFeePerGas;\r\n    bytes paymasterAndData;\r\n    bytes signature;\r\n}\n"})}),"\n",(0,a.jsxs)(t.p,{children:["An example of a ",(0,a.jsx)(t.code,{children:"UserOperation"})," is provided below:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-typescript",children:"const emptyUserOp: UserOperation = {\r\n    sender: AddressZero,\r\n    callData: '0x',\r\n    nonce: 0,\r\n    preVerificationGas: 0,\r\n    verificationGasLimit: 100000,\r\n    callGasLimit: 0,\r\n    maxFeePerGas: 0,\r\n    maxPriorityFeePerGas: 0,\r\n    signature: '0x'\r\n}\n"})}),"\n",(0,a.jsxs)(t.p,{children:["In contrast to the traditional approach of sending signed transactions to a mempool for validation, the initial step in ERC-4337 involves dispatching an operation in the form of a ",(0,a.jsx)(t.strong,{children:"UserOperation"}),". These operations are then forwarded to an alternative mempool. Users have the capability to dispatch multiple UserOperations concurrently through a Bundler smart contract, referred to as Bundler Transactions."]}),"\n",(0,a.jsx)(t.h3,{id:"entry-point-contract-on-ethereum",children:"Entry Point Contract on Ethereum"}),"\n",(0,a.jsxs)(t.p,{children:["The ",(0,a.jsx)(t.strong,{children:"EntryPoint"})," (EP) contract on Ethereum, found at ",(0,a.jsx)(t.a,{href:"https://etherscan.io/address/0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789",children:"0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789"}),", is crucial for handling ",(0,a.jsx)(t.code,{children:"bundlerTransactions"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:["You can explore this contract using Solidity's IDE ",(0,a.jsx)(t.code,{children:"${SOLIDE_URL}/1/0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789)"})]}),"\n",(0,a.jsxs)(t.p,{children:["As of writing this, its contract version is ",(0,a.jsx)(t.code,{children:"0.6.0"})," and serves as the main hub for processing batches of ",(0,a.jsx)(t.code,{children:"UserOperations"}),". The contract offers two main methods: ",(0,a.jsx)(t.code,{children:"handleOps"})," and ",(0,a.jsx)(t.code,{children:"handleAggregatedOps"}),". We'll focus on ",(0,a.jsx)(t.code,{children:"handleOps"})," for now, leaving ",(0,a.jsx)(t.code,{children:"handleAggregatedOps"})," for later discussion."]}),"\n",(0,a.jsxs)(t.h2,{id:"point_right-handleops",children:["\ud83d\udc49"," handleOps"]}),"\n",(0,a.jsxs)(t.p,{children:["The main flow of using the EntryPoint typically comes from the ",(0,a.jsx)(t.code,{children:"Bundler"})," contracts which are called the ",(0,a.jsx)(t.code,{children:"handleOps()"})]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-solidity",children:"function handleOps(UserOperation[] calldata ops, address payable beneficiary) public nonReentrant\n"})}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Non-Reentrant Modifier"}),": This modifier prevents reentrancy attacks, ensuring the security of the smart contract."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"UserOperation Array"}),": The ",(0,a.jsx)(t.code,{children:"ops"})," array consists of ",(0,a.jsx)(t.code,{children:"UserOperation"})," objects, stored in ",(0,a.jsx)(t.code,{children:"calldata"}),". These objects hold data passed to the contract's entry point."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Beneficiary Address"}),": The ",(0,a.jsx)(t.code,{children:"beneficiary"})," address is where gas refunds are sent after execution. Typically, this address corresponds to the bundler, but it can be set to any desired address."]}),"\n"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-solidity",children:"uint256 opslen = ops.length;\r\nUserOpInfo[] memory opInfos = new UserOpInfo[](opslen);\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Before executing the UserOperations, the EntryPoint will validate each UserOperation. It'll create a ",(0,a.jsx)(t.code,{children:"UserOpInfo"})," array to store the information of each UserOperation."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-solidity",children:"for (uint256 i = 0; i < opslen; i++) {\r\n\tUserOpInfo memory opInfo = opInfos[i];\r\n\t(uint256 validationData, uint256 pmValidationData) = _validatePrepayment(i, ops[i], opInfo);\r\n\t_validateAccountAndPaymasterValidationData(i, validationData, pmValidationData, address(0));\r\n}\n"})}),"\n",(0,a.jsxs)(t.p,{children:["In order to populate the opInfos from the Bundler, the function will undergo validation check in its loops. In order to save gas it'll be in the ",(0,a.jsx)(t.code,{children:"uncheck"})]}),"\n",(0,a.jsxs)(t.p,{children:["Go to implementation information for ",(0,a.jsx)(t.a,{href:"#heavy_check_mark-_validateprepayment",children:"_validatePrepayment"})]}),"\n",(0,a.jsxs)(t.p,{children:["After the validation of both the Account and Paymaster, the validation is checked to see if they expire in ",(0,a.jsx)(t.code,{children:"_validateAccountAndPaymasterValidationData"}),". If the validation is successful, the EntryPoint will execute the UserOperations."]}),"\n",(0,a.jsxs)(t.p,{children:["Go to implementation information for ",(0,a.jsx)(t.a,{href:"#heavy_check_mark-validateaccountandpaymastervalidationdata",children:"_validateAccountAndPaymasterValidationData"})]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-solidity",children:"uint256 collected = 0;\r\nemit BeforeExecution();\r\n\r\nfor (uint256 i = 0; i < opslen; i++) {\r\n    collected += _executeUserOp(i, ops[i], opInfos[i]);\r\n}\r\n\r\n_compensate(beneficiary, collected);\n"})}),"\n",(0,a.jsx)(t.p,{children:"With all validation complete it'll emit an event before execution begins. Then start iterating through each user operation, executing them and adding the gas fees consumed by each operation to the total collected amount. After all operations are executed, it compensates the specified beneficiary with the total collected gas fees, transferring them to the beneficiary's address."}),"\n",(0,a.jsxs)(t.p,{children:["Go to implementation information for ",(0,a.jsx)(t.a,{href:"#wrench-_executeuserop",children:"_executeUserOp"})]}),"\n",(0,a.jsxs)(t.p,{children:["Go to implementation information for ",(0,a.jsx)(t.a,{href:"#dollar-_compensate",children:"_compensate"})]}),"\n",(0,a.jsxs)(t.h2,{id:"heavy_check_mark-_validateprepayment",children:["\u2714\ufe0f"," _validatePrepayment"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-solidity",children:"function _validatePrepayment(uint256 opIndex, UserOperation calldata userOp, UserOpInfo memory outOpInfo)\r\n\tprivate returns (uint256 validationData, uint256 paymasterValidationData)\n"})}),"\n",(0,a.jsxs)(t.p,{children:["The ",(0,a.jsx)(t.code,{children:"_validatePrepayment"})," function serves a pivotal role in upholding the integrity and safety of UserOperations within the account abstraction framework."]}),"\n",(0,a.jsx)(t.p,{children:"It takes in three parameters:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"opIndex"}),": The index of the operation."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"userOp"}),": The UserOperation data structure containing essential information about the operation."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"outOpInfo"}),": A UserOpInfo structure used for storing operation-specific data during validation."]}),"\n"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-solidity",children:"uint256 preGas = gasleft();\r\nMemoryUserOp memory mUserOp = outOpInfo.mUserOp;\r\n_copyUserOpToMemory(userOp, mUserOp);\r\noutOpInfo.userOpHash = getUserOpHash(userOp);\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Initially, the function tracks the remaining gas at the start of its execution. Utilizing the built-in Solidity function ",(0,a.jsx)(t.code,{children:"gasleft()"}),", it determines the amount of gas remaining within the current Ethereum transaction. ",(0,a.jsxs)(t.em,{children:["Throughout the call to the EntryPoint, ",(0,a.jsx)(t.code,{children:"gasleft"})," is employed to inform decisions based on the gas supplied by the Bundler."]})," Subsequently, it creates a copy of the data from ",(0,a.jsx)(t.code,{children:"userOp"})," into memory for efficient processing. Following this, it calculates a hash of the UserOperation data using the ",(0,a.jsx)(t.code,{children:"getUserOpHash"})," function. This hash functions as a unique identifier for the operation, facilitating validation processes."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-solidity",children:'require(maxGasValues <= type(uint120).max, "AA94 gas values overflow");\n'})}),"\n",(0,a.jsx)(t.p,{children:"This line of code ensures that certain numeric values within the UserOperation data, such as gas limits, do not exceed the maximum value representable by a 120-bit unsigned integer. This safeguard is implemented to mitigate the risk of overflow during subsequent calculations."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-solidity",children:"uint256 gasUsedByValidateAccountPrepayment;\r\n(uint256 requiredPreFund) = _getRequiredPrefund(mUserOp);\r\n(gasUsedByValidateAccountPrepayment, validationData) = _validateAccountPrepayment(opIndex, userOp, outOpInfo, requiredPreFund);\n"})}),"\n",(0,a.jsxs)(t.p,{children:["The function continues by calculating the gas needed to pre-fund the operation. This calculation is based on the UserOperation data and specific conditions defined within the ",(0,a.jsx)(t.code,{children:"_getRequiredPrefund"})," function. Furthermore, the function conducts validation checks using ",(0,a.jsx)(t.code,{children:"_validateAccountPrepayment"}),". These checks ensure that the account ",(0,a.jsx)(t.em,{children:"(Smart Contract Wallet)"}),", possesses adequate funds and allowances to cover the operation's gas costs."]}),"\n",(0,a.jsxs)(t.p,{children:["Go to implementation information for ",(0,a.jsx)(t.a,{href:"#_validateaccountprepayment",children:"_validateAccountPrepayment"})]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-solidity",children:"if (mUserOp.paymaster != address(0)) {\r\n\t(context, paymasterValidationData) = _validatePaymasterPrepayment(opIndex, userOp, outOpInfo, requiredPreFund, gasUsedByValidateAccountPrepayment);\r\n}\n"})}),"\n",(0,a.jsxs)(t.p,{children:["This next stage is optional, contingent upon the bundler's inclusion of a paymaster for the UserOperation. ",(0,a.jsx)(t.em,{children:"The paymaster is an integral component in Account Abstraction as it enables users to settle transaction fees such as utilizing ERC-20 tokens rather than native tokens like ETH. Acting as an intermediary, the Paymaster gathers ERC-20 tokens from users and remits ETH to the blockchain for transaction facilitation."})," Therefore, this aspect is a crucial addition to the EntryPoint, permitting the Bundler to cover the UserOperation costs using ERC-20 tokens instead of native tokens such as ETH."]}),"\n",(0,a.jsxs)(t.p,{children:["Go to implementation information for ",(0,a.jsx)(t.a,{href:"#_validatepaymasterprepayment",children:"_validatePaymasterPrepayment"})]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-solidity",children:'uint256 gasUsed = preGas - gasleft();\r\n\r\nif (userOp.verificationGasLimit < gasUsed) {\r\nrevert FailedOp(opIndex, "AA40 over verificationGasLimit");\r\n}\r\noutOpInfo.prefund = requiredPreFund;\r\noutOpInfo.contextOffset = getOffsetOfMemoryBytes(context);\r\noutOpInfo.preOpGas = preGas - gasleft() + userOp.preVerificationGas;\n'})}),"\n",(0,a.jsxs)(t.p,{children:["After completing the necessary gas calculations and validations, the function ensures that the gas utilized during validation does not surpass the specified verification gas limit. Upon success, it finalizes the pre-funding details within the ",(0,a.jsx)(t.code,{children:"outOpInfo"})," structure, encompassing the pre-fund amount, memory context offset, and pre-operation gas usage."]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"outOpInfo.prefund"})," is set to the ",(0,a.jsx)(t.code,{children:"requiredPreFund"})," value, which represents the maximum gas fee deducted from the deposit on EP."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"outOpInfo.contextOffset"})," is designated as the offset of the context object in memory. Note that the context object is returned by the ",(0,a.jsx)(t.code,{children:"Paymaster.validatePaymasterUserOp"})," call. By storing only the memory offset of the context object, we alleviate the need to pass around the entire context object while invoking internal methods."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"outOpInfo.preOpGas"})," is determined as the sum of the total gas used thus far and the ",(0,a.jsx)(t.code,{children:"userOp.preVerificationGas"}),"."]}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["In summary, ",(0,a.jsx)(t.code,{children:"_validatePrepayment"})," assumes the role of guaranteeing the validity and safety of UserOperations within the account abstraction framework. It encompasses crucial tasks such as gas tracking, hashing, validation, and pre-funding calculations, ensuring the seamless and secure execution of operations."]}),"\n",(0,a.jsxs)(t.p,{children:["Go back to ",(0,a.jsx)(t.a,{href:"#point_right-handleops",children:"handleOps"})]}),"\n",(0,a.jsx)(t.h3,{id:"_validateaccountprepayment",children:"_validateAccountPrepayment"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-solidity",children:"_createSenderIfNeeded(opIndex, opInfo, op.initCode);\n"})}),"\n",(0,a.jsxs)(t.p,{children:["This internal method is crucial for validating the operation with a Smart Contract Wallet (SCW). Initially, it calls upon a Factory contract to create the account if required, utilizing ",(0,a.jsx)(t.code,{children:"_createSenderIfNeeded"}),". The Wallet contract generated by this factory must adhere to ",(0,a.jsx)(t.code,{children:"interfaces/IAccount.sol"}),", which includes the ",(0,a.jsx)(t.code,{children:"validateUserOp"})," function. This function is essential for validating the UserOp's signature, enabling the EntryPoint to execute operations on a Wallet account."]}),"\n",(0,a.jsxs)(t.p,{children:["Once the Smart Contract Wallet is deemed valid for further validation, the method proceeds to perform calculations on the gas funds and validate the ",(0,a.jsx)(t.code,{children:"validateUserOp"})," function on the SCW if and only if ",(0,a.jsx)(t.code,{children:"paymaster == address(0)"}),". This condition signifies that the SCW, either passed or generated, will be responsible for covering the current UserOperation execution(s)."]}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Important stage in handleOps"}),"\r\nAt this point, the EntryPoint call stack should ",(0,a.jsx)(t.code,{children:"handleOps.validatePrePayment._validateAccountPrepayment"}),", where the EntryPoint is validating that the SCW has enough gas to cover the UserOperation."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-solidity",children:"try IAccount(sender).validateUserOp{gas : mUserOp.verificationGasLimit}(op, opInfo.userOpHash, missingAccountFunds)\n"})}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsxs)(t.em,{children:["There is also the introduction of reverting the entire transaction if validations fail from the SCW or the call runs out of gas.  Mainly the ",(0,a.jsx)(t.code,{children:"FailedOp"})," will revert the transaction."]})}),"\n",(0,a.jsxs)(t.p,{children:["Upon successful validation, both ",(0,a.jsx)(t.code,{children:"gasUsedByValidateAccountPrepayment"})," and ",(0,a.jsx)(t.code,{children:"validationData"})," provided by the SCW through its ",(0,a.jsx)(t.code,{children:"IAccount"})," interface are captured. It is crucial that the validation logic is tailored and executed according to each user's preferences and requirements."]}),"\n",(0,a.jsxs)(t.p,{children:["Go back to ",(0,a.jsx)(t.a,{href:"#heavy_check_mark-_validateprepayment",children:"_validatePrepayment"})]}),"\n",(0,a.jsx)(t.h3,{id:"_validatepaymasterprepayment",children:"_validatePaymasterPrepayment"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-solidity",children:'uint256 preGas = gasleft();\r\nMemoryUserOp memory mUserOp = opInfo.mUserOp;\r\naddress paymaster = mUserOp.paymaster;\r\nDepositInfo storage paymasterInfo = deposits[paymaster];\r\nuint256 deposit = paymasterInfo.deposit;\r\nif (deposit < requiredPreFund) {\r\n    revert FailedOp(opIndex, "AA31 paymaster deposit too low");\r\n}\n'})}),"\n",(0,a.jsxs)(t.p,{children:["Similarly to the ",(0,a.jsx)(t.code,{children:"_validateAccountPrepayment"}),", this time, it'll check the paymaster's deposit balance in EP. If there is enough despot compared to the provided, it'll deduct the that the the requiredPreFund from the Paymaster's deposit,"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-solidity",children:'MemoryUserOp memory mUserOp = opInfo.mUserOp;\r\nuint256 verificationGasLimit = mUserOp.verificationGasLimit;\r\nrequire(verificationGasLimit > gasUsedByValidateAccountPrepayment, "AA41 too little verificationGas");\r\nuint256 gas = verificationGasLimit - gasUsedByValidateAccountPrepayment;\n'})}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.code,{children:"gasUsedByValidateAccountPrepayment"})," calculated by the Account validation, is used to calculate the gas required to pay back the bundler. This is done via ",(0,a.jsx)(t.code,{children:"_getRequiredPrefund"}),". Since the EntryPoint is executing the UserOperations, this means that EntryPoint must ensure it has enough gas to execute those UserOperations and in order for the Bundler to obtain the gas, depends on whether a Paymaster is set up or the Smart Contract Wallet provided."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-solidity",children:"paymasterInfo.deposit = deposit - requiredPreFund\n"})}),"\n",(0,a.jsxs)(t.p,{children:["After deducting the deposit as mentioned call the validationOp's ",(0,a.jsx)(t.code,{children:"validatePaymasterUserOp"})," for paymaster of ",(0,a.jsx)(t.code,{children:"interfaces/IPaymaster.sol"})," and with the \xa0",(0,a.jsx)(t.code,{children:"userOp.verificationGasLimit"}),"\xa0as gas limit and return the validation Data."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-solidity",children:"IPaymaster(paymaster).validatePaymasterUserOp{gas: gas}(op, opInfo.userOpHash, requiredPreFund) returns (bytes memory _context, uint256 _validationData) \n"})}),"\n",(0,a.jsxs)(t.p,{children:["This will return ",(0,a.jsx)(t.em,{children:"context object"})," and ",(0,a.jsx)(t.code,{children:"validationData"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:["Go back to ",(0,a.jsx)(t.a,{href:"#heavy_check_mark-_validateprepayment",children:"_validatePrepayment"})]}),"\n",(0,a.jsxs)(t.h2,{id:"heavy_check_mark-validateaccountandpaymastervalidationdata",children:["\u2714\ufe0f"," validateAccountAndPaymasterValidationData"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-solidity",children:"function _validateAccountAndPaymasterValidationData(uint256 opIndex, uint256 validationData, uint256 paymasterValidationData,\r\n    address expectedAggregator)\n"})}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.code,{children:"validateAccountAndPaymasterValidationData"})," serves to validate the validation data from both the Smart Contract Wallet (SCW) and Paymaster. It verifies if the validation data has expired and reverts the transaction if it has. Notably, in the Ethereum EntryPoint, the ",(0,a.jsx)(t.code,{children:"address(0)"})," represents the ",(0,a.jsx)(t.code,{children:"expectedAggregator"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:["Before unpacking the validationData, An example of validation data is as follows as taken by ",(0,a.jsx)(t.code,{children:"account-abstraction/ethereum/contracts/TokenPaymaster.sol"}),". ",(0,a.jsx)(t.em,{children:"Note this is just an example, other Paymaster's or SCW validation will have different validation data depending on it implementation."})]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-solidity",children:"validationResult = _packValidationData(\r\n\tfalse,\r\n\tuint48(cachedPriceTimestamp + tokenPaymasterConfig.priceMaxAge),\r\n\t0\r\n);\n"})}),"\n",(0,a.jsx)(t.p,{children:"The validationData comprises three components, which are essential for the EntryPoint to validate the UserOperation,"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["Aggregator: This value signifies the success of the aggregator. A value of ",(0,a.jsx)(t.code,{children:"0"})," indicates a successful aggregator. For instance, if ",(0,a.jsx)(t.code,{children:"false"})," is provided, it results in the value ",(0,a.jsx)(t.code,{children:"0"}),", indicating success."]}),"\n",(0,a.jsx)(t.li,{children:"ValidUntil: This represents the start time when the signature is valid."}),"\n",(0,a.jsx)(t.li,{children:"ValidAfter: This denotes the end time when the signature is valid."}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["These components collectively determine whether signature verification was successful. The primary implementation of parsing the validationData is outlined in ",(0,a.jsx)(t.code,{children:"Helper.sol"})," within the ",(0,a.jsx)(t.code,{children:"_parseValidationData"})," function. In essence, this method extracts the aggregator value (an ",(0,a.jsx)(t.code,{children:"address"}),"), the validUntil timestamp (a ",(0,a.jsx)(t.code,{children:"uint48"}),"), and the validAfter timestamp (a ",(0,a.jsx)(t.code,{children:"uint48"}),") from the validationData. If the validUntil value is 0, as observed in the example provided, it signifies that the signature is valid until the maximum value of ",(0,a.jsx)(t.code,{children:"uint48"}),"."]}),"\n",(0,a.jsx)(t.p,{children:"Since both validationData and paymasterValidationData undergo validation in a similar manner, we'll focus on the paymasterValidationData. The validation process involves comparing these values with the current block timestamp in the EntryPoint to ascertain their validity."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-solidity",children:'address pmAggregator;\r\n(pmAggregator, outOfTimeRange) = _getValidationData(paymasterValidationData);\r\nif (pmAggregator != address(0)) {\r\n\trevert FailedOp(opIndex, "AA34 signature error");\r\n}\r\nif (outOfTimeRange) {\r\n\trevert FailedOp(opIndex, "AA32 paymaster expired or not due");\r\n}\n'})}),"\n",(0,a.jsxs)(t.p,{children:["Hence if we go back to the EntryPoint where it'll parse the above ",(0,a.jsx)(t.code,{children:"validationResult"})," as ",(0,a.jsx)(t.code,{children:"paymasterValidationData"})," we see it extracts the ",(0,a.jsx)(t.code,{children:"pmAggregator"})," variable represents the aggregator status obtained from the paymasterValidationData. A value of ",(0,a.jsx)(t.code,{children:"0"})," indicates a successful aggregator, while ",(0,a.jsx)(t.code,{children:"1"})," implies an expired aggregator. With this, if ",(0,a.jsx)(t.code,{children:"pmAggregator"})," is assigned the value of ",(0,a.jsx)(t.code,{children:"address(0)"}),", it signifies that the aggregator is successful as it has the value of ",(0,a.jsx)(t.code,{children:"0"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:["Furthermore, validation is conducted by comparing the current block timestamp with the validUntil and validAfter timestamps obtained from the validation data. The ",(0,a.jsx)(t.code,{children:"outOfTimeRange"})," variable is set based on whether the current timestamp exceeds the validUntil timestamp or falls before the validAfter timestamp. If ",(0,a.jsx)(t.code,{children:"outOfTimeRange"})," is ",(0,a.jsx)(t.code,{children:"true"}),", it indicates that the paymaster has expired or the operation is not yet due."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-solidity",children:"outOfTimeRange = block.timestamp > data.validUntil || block.timestamp < data.validAfter;\n"})}),"\n",(0,a.jsx)(t.p,{children:'In summary, the code snippet checks the status of the aggregator and verifies the validity of the paymaster based on timestamps, ensuring that the operation is executed within the designated time range. If any discrepancy is detected, the function reverts the transaction with an appropriate error message, such as "signature error" or "paymaster expired or not due."'}),"\n",(0,a.jsxs)(t.p,{children:["Go back to ",(0,a.jsx)(t.a,{href:"#point_right-handleops",children:"handleOps"})]}),"\n",(0,a.jsx)(t.h3,{id:"numbermarker",children:"numberMarker()"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-solidity",children:"//place the NUMBER opcode in the code.\r\n// this is used as a marker during simulation, as this OP is completely banned from the simulated code of the\r\n// account and paymaster.\r\nfunction numberMarker() internal view {\r\n    assembly {mstore(0, number())}\r\n}\n"})}),"\n",(0,a.jsxs)(t.p,{children:["This function is mainly useful for the method ",(0,a.jsx)(t.code,{children:"simulateValidation"}),", for tracing and checkpoints throughout the code. For our purpose, we don't need to really worry about this."]})]})}function r(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(i,{...e})}):i(e)}},2345:(e,t,n)=>{n.d(t,{Ay:()=>r});var a=n(4848),s=n(8453);function i(e){const t={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(t.h2,{id:"wrench-_executeuserop",children:["\ud83d\udd27"," _executeUserOp"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-solidity",children:"function _executeUserOp(uint256 opIndex, UserOperation calldata userOp, UserOpInfo memory opInfo) \r\n    private returns (uint256 collected)\n"})}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-solidity",children:"bytes memory context = getMemoryBytesFromOffset(opInfo.contextOffset);\n"})}),"\n",(0,a.jsxs)(t.p,{children:["The code begins by retrieving the context from memory. The context is stored as a byte array and contains essential information needed for the ",(0,a.jsx)(t.code,{children:"Paymaster.postOp"})," function."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-solidity",children:"try this.innerHandleOp(userOp.callData, opInfo, context) returns (\r\n    uint256 _actualGasCost\r\n) {\r\n    collected = _actualGasCost;\r\n}\n"})}),"\n",(0,a.jsxs)(t.p,{children:["The code then attempts to execute the UserOperation by invoking the ",(0,a.jsx)(t.code,{children:"innerHandleOp"})," function. This function, implemented by the Paymaster, takes ",(0,a.jsx)(t.code,{children:"userOp.callData"}),", ",(0,a.jsx)(t.code,{children:"opInfo"}),", and ",(0,a.jsx)(t.code,{children:"context"})," as parameters. Upon invocation, ",(0,a.jsx)(t.code,{children:"innerHandleOp"})," returns the actual gas cost incurred by the operation, which is subsequently added to the ",(0,a.jsx)(t.code,{children:"collected"})," variable."]}),"\n",(0,a.jsxs)(t.p,{children:["Go to implementation information for ",(0,a.jsx)(t.a,{href:"#innerhandleop",children:"innerHandleOp"})]}),"\n",(0,a.jsx)(t.h3,{id:"innerhandleop",children:"innerHandleOp"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-solidity",children:"function innerHandleOp(\r\n    bytes memory callData,\r\n    UserOpInfo memory opInfo,\r\n    bytes calldata context\r\n) external returns (uint256 actualGasCost)\n"})}),"\n",(0,a.jsxs)(t.p,{children:["The ",(0,a.jsx)(t.code,{children:"innerHandleOp"})," method is invoked to execute the ",(0,a.jsx)(t.code,{children:"UserOperation"})," calldata on the wallet contract. Leveraging the ",(0,a.jsx)(t.code,{children:"Exec"})," solidity library, available in ",(0,a.jsx)(t.code,{children:"util/Exec.sol"}),", developers gain access to a range of utility functions designed for diverse contract calls. These include regular ",(0,a.jsx)(t.em,{children:"call"}),", ",(0,a.jsx)(t.em,{children:"staticcall"}),", and ",(0,a.jsx)(t.em,{children:"delegatecall"})," functionalities, along with features for retrieving return data and reverting with explicit byte arrays. Such capabilities empower developers to interact flexibly and efficiently with other contracts directly within Solidity contracts, seamlessly managing value transfers and data retrieval. In the following code snippet, ",(0,a.jsx)(t.code,{children:"Exec.call"})," is utilized\u2014a low-level call function\u2014utilizing the calldata provided by ",(0,a.jsx)(t.code,{children:"userOp.callData"}),"."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-solidity",children:"if (callData.length > 0) {\r\n    bool success = Exec.call(mUserOp.sender, 0, callData, callGasLimit);\r\n    if (!success) {\r\n        bytes memory result = Exec.getReturnData(REVERT_REASON_MAX_LEN);\r\n        if (result.length > 0) {\r\n            emit UserOperationRevertReason(opInfo.userOpHash, mUserOp.sender, mUserOp.nonce, result);\r\n        }\r\n        mode = IPaymaster.PostOpMode.opReverted;\r\n    }\r\n}\n"})}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-solidity",children:"unchecked {\r\n    uint256 actualGas = preGas - gasleft() + opInfo.preOpGas;\r\n    //note: opIndex is ignored (relevant only if mode==postOpReverted, which is only possible outside of innerHandleOp)\r\n    return _handlePostOp(0, mode, opInfo, context, actualGas);\r\n}\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Go to implementation information for ",(0,a.jsx)(t.a,{href:"#_handlepostop",children:"_handlePostOp"})]}),"\n",(0,a.jsx)(t.h3,{id:"_handlepostop",children:"_handlePostOp"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-solidity",children:"function _handlePostOp(uint256 opIndex, IPaymaster.PostOpMode mode, UserOpInfo memory opInfo, bytes memory context, \r\n    uint256 actualGas) private returns (uint256 actualGasCost) \n"})}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-solidity",children:"address refundAddress;\r\nMemoryUserOp memory mUserOp = opInfo.mUserOp;\r\nuint256 gasPrice = getUserOpGasPrice(mUserOp);\r\n\r\naddress paymaster = mUserOp.paymaster;\r\nif (paymaster == address(0)) {\r\n    refundAddress = mUserOp.sender;\r\n} else {\r\n    refundAddress = paymaster;\r\n    // ...\r\n}\n"})}),"\n",(0,a.jsxs)(t.p,{children:["When a paymaster is specified and its validation results in a non-empty context, the surplus amount is reimbursed to the account or paymaster, depending on its involvement in the transaction request. As mentioned, the following code executes the ",(0,a.jsx)(t.code,{children:"IPaymaster"}),"'s ",(0,a.jsx)(t.code,{children:"postOp"})," function, which is another essential method similar to ",(0,a.jsx)(t.code,{children:"validatePaymasterUserOp"}),"."]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsxs)(t.em,{children:["The ",(0,a.jsx)(t.code,{children:"postOp()"})," function acts as a post-execution hook after completing a user operation. It manages tasks to be executed upon successful validation of the user operation, such as handling custom token payments for transaction fees. For example, if a user chooses to pay with an ERC-20 token, the entry point invokes ",(0,a.jsx)(t.code,{children:"postOp()"})," after executing the operation and provides information about gas consumption. Importantly, access to ",(0,a.jsx)(t.code,{children:"postOp()"})," is contingent upon the validation context generated by ",(0,a.jsx)(t.code,{children:"validatePaymasterUserOp()"})," not being null. This mechanism simplifies the process of managing token payments and facilitates smooth transaction processing on the blockchain."]})}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-solidity",children:'if (context.length > 0) {\r\n    actualGasCost = actualGas * gasPrice;\r\n    if (mode != IPaymaster.PostOpMode.postOpReverted) {\r\n        IPaymaster(paymaster).postOp{gas : mUserOp.verificationGasLimit}(mode, context, actualGasCost);\r\n    } else {\r\n        // solhint-disable-next-line no-empty-blocks\r\n        try IPaymaster(paymaster).postOp{gas : mUserOp.verificationGasLimit}(mode, context, actualGasCost) {}\r\n        catch Error(string memory reason) {\r\n            revert FailedOp(opIndex, string.concat("AA50 postOp reverted: ", reason));\r\n        }\r\n        catch {\r\n            revert FailedOp(opIndex, "AA50 postOp revert");\r\n        }\r\n    }\r\n}\n'})}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-solidity",children:'actualGas += preGas - gasleft();\r\nactualGasCost = actualGas * gasPrice;\r\nif (opInfo.prefund < actualGasCost) {\r\n    revert FailedOp(opIndex, "AA51 prefund below actualGasCost");\r\n}\r\nuint256 refund = opInfo.prefund - actualGasCost;\r\n_incrementDeposit(refundAddress, refund);\r\nbool success = mode == IPaymaster.PostOpMode.opSucceeded;\r\nemit UserOperationEvent(opInfo.userOpHash, mUserOp.sender, mUserOp.paymaster, mUserOp.nonce, success, actualGasCost, actualGas);\n'})}),"\n",(0,a.jsx)(t.p,{children:"After determining the refund address and ensuring that the paymaster context isn't empty, the code proceeds to calculate the actual gas usage and its associated cost during the execution of a smart contract operation. It then verifies whether the pre-funded amount is adequate to cover the gas cost. If not, the transaction is reverted. Any excess pre-funded amount is calculated as a refund and subsequently added to the deposit of the specified address. Finally, the success status of the operation is determined based on the paymaster's mode setting."}),"\n",(0,a.jsx)(t.p,{children:"Additionally:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["The ",(0,a.jsx)(t.code,{children:"_incrementDeposit"})," function in the ",(0,a.jsx)(t.code,{children:"StakeManager"})," contract is invoked to increase the paymaster's deposit by the actual gas cost."]}),"\n",(0,a.jsxs)(t.li,{children:["The ",(0,a.jsx)(t.code,{children:"actualGasCost = actualGas * gasPrice"})," calculation determines the actual gas cost of the operation, which is stored as the value of ",(0,a.jsx)(t.code,{children:"collected"})," in the ",(0,a.jsx)(t.code,{children:"handleOps"})," function."]}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["Go back to ",(0,a.jsx)(t.a,{href:"#point_right-handleops",children:"handleOps"})]}),"\n",(0,a.jsxs)(t.h2,{id:"dollar-_compensate",children:["\ud83d\udcb5"," _compensate"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-solidity",children:'/**\r\n * compensate the caller\'s beneficiary address with the collected fees of all UserOperations.\r\n * @param beneficiary the address to receive the fees\r\n * @param amount amount to transfer.\r\n */\r\nfunction _compensate(address payable beneficiary, uint256 amount) internal {\r\n    require(beneficiary != address(0), "AA90 invalid beneficiary");\r\n    (bool success,) = beneficiary.call{value : amount}("");\r\n    require(success, "AA91 failed send to beneficiary");\r\n}\n'})}),"\n",(0,a.jsxs)(t.p,{children:["The final step is to compensate the beneficiary with the collected fees. The collected fees are transferred to the beneficiary address. The beneficiary address can be any address where the bundler wants to receive the refund as provided in the ",(0,a.jsx)(t.code,{children:"handleOps"}),"."]}),"\n",(0,a.jsx)(t.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,a.jsxs)(t.p,{children:["In conclusion, the EntryPoint efficiently executes the bundled UserOperations and ensures fair compensation for the beneficiary by collecting fees. This is the flow of ",(0,a.jsx)(t.code,{children:"handleOp"}),". There is also ",(0,a.jsx)(t.code,{children:"handleAggregatorOp"}),". Note also the EntryPoint extends ",(0,a.jsx)(t.code,{children:"StakeManger"})," found in ",(0,a.jsx)(t.code,{children:"core/StakeManger.sol"})," which as mentioned is responsible for managing ",(0,a.jsx)(t.code,{children:"deposits"})," and stakes to ensure reimbursement for beneficiaries during the execution of handleOps and handleAggregatedOps functions. Deposits represent balances used to cover the costs of UserOperations, while stakes are values locked for a specified duration by paymasters, crucial for the reputation system.  To learn more about the EIP proposal and its specifications, you can refer to the official document ",(0,a.jsx)(t.a,{href:"https://eips.ethereum.org/EIPS/eip-4337",children:"here"}),"."]})]})}function r(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(i,{...e})}):i(e)}},3456:(e,t,n)=>{n.d(t,{A:()=>s});var a=n(4848);const s=e=>{let{src:t}=e;return(0,a.jsx)("img",{className:"rounded-lg w-full",src:t,alt:"cover"})}},2168:(e,t,n)=>{n.d(t,{A:()=>s});var a=n(4848);const s=e=>{let{url:t}=e;return(0,a.jsx)("iframe",{src:t,height:"400",width:"300",style:{borderRadius:"8px",width:"100%",overflow:"hidden"}})}},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>o});var a=n(6540);const s={},i=a.createContext(s);function r(e){const t=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),a.createElement(i.Provider,{value:t},e.children)}}}]);
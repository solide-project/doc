"use strict";(self.webpackChunksolide_docs=self.webpackChunksolide_docs||[]).push([[4733],{3932:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>m,contentTitle:()=>h,default:()=>g,frontMatter:()=>d,metadata:()=>p,toc:()=>u});var s=n(4848),o=n(8453),r=(n(6540),n(2168)),a=n(3456),i=n(2416),c=n(2754),l=n(2011);const d={slug:"/solidity/create3",title:"Exploring CREATE3 - Simplifying Smart Contract Deployment on Ethereum",image:"https://raw.githubusercontent.com/solide-project/docs/master/static/img/blog/solidity-create3.png",authors:["p"],tags:["open-source","smart-contract","development-tool"]},h=void 0,p={permalink:"/blog/solidity/create3",source:"@site/blog/solidity/create3/2024-04-03-index.md",title:"Exploring CREATE3 - Simplifying Smart Contract Deployment on Ethereum",description:"<BlogCoverImage",date:"2024-04-03T00:00:00.000Z",tags:[{inline:!0,label:"open-source",permalink:"/blog/tags/open-source"},{inline:!0,label:"smart-contract",permalink:"/blog/tags/smart-contract"},{inline:!0,label:"development-tool",permalink:"/blog/tags/development-tool"}],readingTime:.13,hasTruncateMarker:!1,authors:[{name:"P",title:"Software Engineer @ Solide",url:"https://github.com/solide-project",imageURL:"https://avatars.githubusercontent.com/u/154510112?s=200&v=4",key:"p"}],frontMatter:{slug:"/solidity/create3",title:"Exploring CREATE3 - Simplifying Smart Contract Deployment on Ethereum",image:"https://raw.githubusercontent.com/solide-project/docs/master/static/img/blog/solidity-create3.png",authors:["p"],tags:["open-source","smart-contract","development-tool"]},unlisted:!1,nextItem:{title:"ERC4337 - Paymaster",permalink:"/blog/ethereum/erc4337/paymaster"}},m={authorsImageUrls:[void 0]},u=[...c.RM,...l.RM];function y(e){return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(a.A,{src:"https://raw.githubusercontent.com/solide-project/docs/master/static/img/blog/solidity-create3.png"}),"\n",(0,s.jsx)(r.A,{url:`${i.e}/?url=https://github.com/solide-project/solide-guides/blob/master/src/solide/Create/Deployer.sol`}),"\n",(0,s.jsx)(c.Ay,{}),"\n",(0,s.jsx)(r.A,{url:`${i.e}/?url=https://github.com/solide-project/solide-guides/blob/master/src/solide/Create/Ownerable.sol`}),"\n",(0,s.jsx)(l.Ay,{})]})}function g(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(y,{...e})}):y()}},2754:(e,t,n)=>{n.d(t,{Ay:()=>i,RM:()=>r});var s=n(4848),o=n(8453);const r=[{value:"What is Create3",id:"what-is-create3",level:2},{value:"Solmate CREATE3",id:"solmate-create3",level:2},{value:"Looking at the Deployer Example contract",id:"looking-at-the-deployer-example-contract",level:2},{value:"Deploy using CREATE3",id:"deploy-using-create3",level:2}];function a(e){const t={a:"a",code:"code",em:"em",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h2,{id:"what-is-create3",children:"What is Create3"}),"\n",(0,s.jsxs)(t.p,{children:["With the advancement of multichain development, ",(0,s.jsx)(t.strong,{children:"CREATE3"})," emerges as a transformative and cheap alternative to the deployment of smart contracts. With the existing Solidity opcodes such as ",(0,s.jsx)(t.code,{children:"create"})," and ",(0,s.jsx)(t.code,{children:"create2"}),", the Create3 is built upon the solidity of ",(0,s.jsx)(t.code,{children:"create2"})," to grant developers control over contract deployment. By enabling developers to predetermine contract addresses before deployment, CREATE3 imbues them with a newfound sense of agency. This new approach not only enhances control but also fosters consistency and uniformity across Ethereum Virtual Machine (EVM) blockchains, allowing for the synchronization of smart contract ecosystems. Whether navigating the Ethereum mainnet, testnets, or private networks, CREATE3 facilitates the harmonious deployment of contracts with identical addresses, thereby heralding a new era of streamlined blockchain development."]}),"\n",(0,s.jsx)(t.h2,{id:"solmate-create3",children:"Solmate CREATE3"}),"\n",(0,s.jsxs)(t.p,{children:["For a more technical perspective, let's dive into Solmate's CREATE3 library, which is designed for deploying smart contracts to deterministic addresses without necessitating an initcode factor. The CREATE3 ",(0,s.jsx)(t.code,{children:"deploy"})," method operates by leveraging ",(0,s.jsx)(t.code,{children:"create2"})," initially to deploy a CREATE factory, with its nonce set to 1 which then is used to deploy the desired derived contract."]}),"\n",(0,s.jsx)(t.p,{children:"Another important part is the Proxy Bytecode."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-solidity",children:'bytes internal constant PROXY_BYTECODE = hex"67_36_3d_3d_37_36_3d_34_f0_3d_52_60_08_60_18_f3";\n'})}),"\n",(0,s.jsxs)(t.p,{children:["The proxy bytecode essentially acts as an intermediary contract that executes the ",(0,s.jsx)(t.code,{children:"create"}),' opcode within its context. By deploying this proxy contract with a unique salt value and having it call "create" with its current nonce (starting at 1 upon first use), the contract bytecode itself becomes independent of the address derivation process. This means that the address of the deployed contract is determined solely by the creator\'s address, the salt value, and the hash of the proxy bytecode, without being influenced by the specific bytecode of the contract being deployed. This is what makes the contracts deterministic and predictable in their deployments, and how developers can ensure resulting contract addresses deployed on other networks are consistent.']}),"\n",(0,s.jsxs)(t.p,{children:["Then we deploy this proxy contract as a new contract using the ",(0,s.jsx)(t.code,{children:"create2"})," opcode. The create2 opcode will take in the ",(0,s.jsx)(t.em,{children:"ether value"})," which is defined as ",(0,s.jsx)(t.code,{children:"0"}),", the ",(0,s.jsx)(t.em,{children:"bytecode of the proxy contract"})," and offset by 32 bytes to skip the first 32 bytes which represent the length of the bytecode, then the ",(0,s.jsx)(t.em,{children:"bytecode loaded from memory"})," and the ",(0,s.jsx)(t.em,{children:"salt"})," used for deterministic address derivation."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-solidity",children:"deployed = getDeployed(salt);\r\n(bool success, ) = proxy.call{value: value}(creationCode);\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Following that the ",(0,s.jsx)(t.code,{children:"getDeployed"})," function is called to retrieve the address of the deployed contract based on the provided salt value. Subsequently, the proxy contract is invoked with the ",(0,s.jsx)(t.code,{children:"creationCode"})," to initialize the deployed contract."]}),"\n",(0,s.jsx)(t.p,{children:"There are also two required checks,"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-solidity",children:'require(proxy != address(0), "DEPLOYMENT_FAILED");\r\nrequire(success && deployed.code.length != 0, "INITIALIZATION_FAILED");\n'})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"The first statement ensures that the deployment was successful by checking that the proxy address is not zero."}),"\n",(0,s.jsx)(t.li,{children:"the second statement verifies that the initialization was successful and that the deployed contract's bytecode is not empty."}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"So in general the steps to deploying a smart contract using create3 is,"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["creating a Factory contract (",(0,s.jsx)(t.code,{children:"Deployer.sol"}),")"]}),"\n",(0,s.jsxs)(t.li,{children:["calls ",(0,s.jsx)(t.code,{children:"create3.deploy"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["calls ",(0,s.jsx)(t.code,{children:"create2"})," to create a proxy contract"]}),"\n",(0,s.jsx)(t.li,{children:"the proxy contract will be called"}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"create"})," from the proxy contract to create the ",(0,s.jsx)(t.strong,{children:"contract"})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"looking-at-the-deployer-example-contract",children:"Looking at the Deployer Example contract"}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"Deployer.sol"})," contract is essentially a ",(0,s.jsx)(t.strong,{children:"factory contract"})," that deploys the contract bytecode to a deterministic address. The contract has a ",(0,s.jsx)(t.code,{children:"deploy"})," method that takes in the salt value and can take the bytecode of the contract to be deployed. In a more generic sense, you can pass any bytecode in so the ",(0,s.jsx)(t.code,{children:"deployer()"})," method can be,"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-solidity",children:"function deploy(bytes memory _salt, bytes memory _bytecode, /* more args for constructor */) external {\r\n    bytes memory bc = abi.encodePacked(\r\n        _bytecode,\r\n        abi.encode(msg.sender)\r\n        // args, \r\n    );\r\n\r\n    CREATE3.deploy(keccak256(_salt), bc, _value);\r\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["For this contract, we've encapsulated the deployment of a contract identified as ",(0,s.jsx)(t.code,{children:"Ownerable.sol"}),". Utilizing the built-in methods, we extract the bytecode of ",(0,s.jsx)(t.code,{children:"Ownerable"})," and subsequently invoke the ",(0,s.jsx)(t.code,{children:"create3.deploy"})," function from the Solmate library. This invocation passes along the salt, the extracted bytecode, and any specified ether value as parameters. The ",(0,s.jsx)(t.code,{children:"create3.deploy"})," function is then responsible for deploying the contract using the provided bytecode."]}),"\n",(0,s.jsx)(t.h2,{id:"deploy-using-create3",children:"Deploy using CREATE3"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsxs)(t.em,{children:["It is important to note the given example using CREATE3 on multichain with the same address, you ",(0,s.jsx)(t.strong,{children:"MUST"})," use a wallet with the same nonce on each network. The best solution is to create an entirely new wallet and send some funds on each chain."]})}),"\n",(0,s.jsxs)(t.p,{children:["For our demonstration, we'll deploy contracts on the ",(0,s.jsx)(t.em,{children:"BASE Sepolia"})," and ",(0,s.jsx)(t.em,{children:"Polygon Mumbai"})," testnet. Begin by compiling and deploying ",(0,s.jsx)(t.code,{children:"Deployer.sol"}),". This action will advance the nonce of your wallet by one once the transaction is completed. Following this, switch your Metamask to the Mumbai testnet and deploy using the same newly created wallet. The outcome should be consistent across both networks. It's important to note that the ",(0,s.jsx)(t.code,{children:"Deployer.sol"})," used in both instances is identical, ensuring uniformity in the deployment process."]}),"\n",(0,s.jsx)(t.p,{children:"The examples of deployers on both networks are as follows,"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"https://sepolia.basescan.org/address/0xfeB362F2148F1303ea6Bf026d32071EA295e25ac",children:"Base: 0xfeB362F2148F1303ea6Bf026d32071EA295e25ac"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"https://mumbai.polygonscan.com/address/0xfeB362F2148F1303ea6Bf026d32071EA295e25ac",children:"Mumbai: 0xfeB362F2148F1303ea6Bf026d32071EA295e25ac"})}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["With CREATE3, we gain the flexibility to selectively target a specific address for contract deployment by using ",(0,s.jsx)(t.em,{children:"a salt"}),". For simplicity, let's use the address ",(0,s.jsx)(t.code,{children:"0xfeB362F2148F1303ea6Bf026d32071EA295e25ac"})," as the salt. The Deployer contract includes a function named ",(0,s.jsx)(t.code,{children:"getDeployer"}),", which, as mentioned, calculates the contract address using the provided salt. Although initially, no contract is deployed at this address, the ",(0,s.jsx)(t.code,{children:"getDeployer"})," can compute the output ",(0,s.jsx)(t.code,{children:"Ownerable"})," address for the contract wallet specified with a salt. This approach ensures that the derived address serves as the deployment target for the contract's implementation in bytecode. Importantly, this guarantees that the address will be consistent across different chains, assuming the deploying wallet's nonce remains the same. We should keep the output address in mind, as it'll be the one we can compare across when using ",(0,s.jsx)(t.code,{children:"deploy"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["To deploy with the CREATE3, the Deployer wrapped the ",(0,s.jsx)(t.code,{children:"deploy"})," from create3 and hence we can pass the the ",(0,s.jsx)(t.code,{children:"_salt"})," as whatever byte we want say, ",(0,s.jsx)(t.code,{children:"0xfeB362F2148F1303ea6Bf026d32071EA295e25ac"}),". After a successful deployment, you can verify the contract on a block explorer by checking out the transaction."]})]})}function i(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}},2011:(e,t,n)=>{n.d(t,{Ay:()=>i,RM:()=>r});var s=n(4848),o=n(8453);const r=[];function a(e){const t={a:"a",code:"code",p:"p",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(t.p,{children:["After deploying, we can access the ",(0,s.jsx)(t.code,{children:"Ownerable.sol"})," (with ",(0,s.jsx)(t.a,{href:"https://solide0x.tech/?url=https://github.com/solide-project/solide-guides/blob/master/src/solide/Create/Ownerable.sol",children:"Solide IDE"}),") contract through the provided URL to interact with its features, such as the ",(0,s.jsx)(t.code,{children:"getOwner"})," function, which should identify the deploying wallet as the owner. To achieve consistent contract addresses across different chains, repeat this deployment process on an alternative blockchain, such as the Mumbai testnet, employing the identical salt. This method showcases CREATE3's ability to facilitate uniform contract addresses across various chains, underscoring its utility for cross-chain contract deployment. Should there be a need to modify the contract address, altering the salt value or ensuring the nonce differs across networks can accomplish this. Furthermore, if deploying a distinct contract while desiring the same address, leveraging the ",(0,s.jsx)(t.code,{children:"deploy()"})," function with the original salt allows for this flexibility."]}),"\n",(0,s.jsxs)(t.p,{children:["In essence, CREATE3 empowers developers with enhanced control over the generation of smart contract addresses on Ethereum, presenting new opportunities for the development of decentralized applications with increased flexibility and uniformity across diverse networks. However, it's important to acknowledge that deploying contracts via CREATE3 may incur higher costs compared to the ",(0,s.jsx)(t.code,{children:"create"})," and ",(0,s.jsx)(t.code,{children:"create2"})," methods."]})]})}function i(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}},3456:(e,t,n)=>{n.d(t,{A:()=>o});var s=n(4848);const o=e=>{let{src:t}=e;return(0,s.jsx)("img",{className:"rounded-lg w-full",src:t,alt:"cover"})}},2168:(e,t,n)=>{n.d(t,{A:()=>o});var s=n(4848);const o=e=>{let{url:t}=e;return(0,s.jsx)("iframe",{src:t,height:"400",width:"300",style:{borderRadius:"8px",width:"100%",overflow:"hidden"}})}},2416:(e,t,n)=>{n.d(t,{e:()=>s});const s="https://solide0x.tech"},8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>i});var s=n(6540);const o={},r=s.createContext(o);function a(e){const t=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),s.createElement(r.Provider,{value:t},e.children)}}}]);